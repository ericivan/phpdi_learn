- [安装](####安装)
- [基本使用](####基本使用)
- [绑定方式](####绑定方式)







#### 安装

> composer require php-di/php-di



#### 基本使用

> 现在有一个Class Mail，一个Class UserManager，我们把Mail依赖注入到 UserManager中，基本写法如下



```php
class Mailer
{
    public function mail($recipient, $content)
    {
        // send an email to the recipient
    }
}
```



```php
class UserManager
{
    private $mailer;

    public function __construct(Mailer $mailer)
    {
        $this->mailer = $mailer;
    }

    public function register($email, $password)
    {
        $this->mailer->mail($email, 'Hello and welcome!');
    }
}

$mailer = new Mailer();
$userManager = new UserManager($mailer);
```

上面代码中最后两行使我们依赖注入的使用，现在我们利用php-di库进行注入

```Php
$container=new Container();

$builer=new DI\ContainerBuiler();

$builder->addDefinitions([
    'UserManager' => \DI\create(\Modern\Di\UserManager::class)
        ->constructor(\DI\get('Mailer')),
    'Mailer'=>\DI\factory(function () {
        return new \Modern\Di\Mailer();
    })
]);

$container = $builder->build();

//获取对象
$userManager=$container->get('UserManager');
```

这段代码中，通过addDefinitions方法进行绑定，get方法获取到注入的对象，mailer对象已经在方法前面进行了注入，获取到容器对象的时候无需再次创建注入对象，十分方便



#### 绑定方式

像上面的例子一样，在方法addDefinitions中进行绑定，以数组的方式作为参数

```php
$containerBuilder->addDefinitions([
    // place your definitions here
]);
```

数组格式：

1.PHP5.5 魔术常量

```php
return [
  LoggerInterface::class => DI\create(Logger::class)
]
```

2.PHP5.6 使用方法导入

```php
return [
    'Foo' => DI\create()
        ->constructor(DI\get('Bar')),
];
```

定义类型功能十分强大，包括下面几种定义

- values

```php
//简单的php数组格式

return [
  'host'=>'localhost',
  'company.emp'=>[
      'name',
      'age'
  ]
]
```

该方法定义对象也行(该做法无法做到延迟加载)

```php
return [
  'Mail'=>new Mailer(),
]
```

- factories

使用辅助方法DI\factory()

```php
use Psr\Container\ContainerInterface;
use function DI\factory;

return [
    'Foo' => function (ContainerInterface $c) {
        return new Foo($c->get('db.host'));
    },

    // Same as
    'Foo' => factory(function (ContainerInterface $c) {
        return new Foo($c->get('db.host'));
    }),
];
```

如果闭包中参数没有指定类型，可以使用方法parameter来指定

```php
return [
    'Database' => DI\factory(function ($host) {...})
        ->parameter('host', DI\get('db.host')),
];
```
需要注意的是，上述方法中注入容器的是Psr\Container\ContainerInterface，并非DI\Container.



可以使用工厂模式进行定义

```Php
class FooFactory
{
    public function create(Bar $bar)
    {
        return new Foo($bar);
    }
}
```

官方推荐使用方法：

```
return [
    Foo::class => DI\factory([FooFactory::class, 'create']),
    // alternative syntax:
    Foo::class => DI\factory('Namespace\To\FooFactory::create'),
];
```

上述代码中，第一种方法为推荐方法，因为第二种方法没有办法进行延迟加载，每个请求过来都进行不必要的操作

>  特别注意，上面的大司马中如果create是静态方法，那对象不会被创建。

> 使用factory(['foo_bar','build'])的时候foo_bar 可以是被绑定过的其他对象

> 可以使用有魔术方法__invoke 的对象

> 所有的闭包都被认为是php-di的工厂，即使是嵌套了其他定义像 create(),env()

- objects

- Autowrited object

- aliases

- environment variables

- string expressions

- arrays

- wildcards

  ​